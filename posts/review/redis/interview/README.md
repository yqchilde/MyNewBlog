---
title: Redis八股题
description: Redis面经，资源从网络收集
date: 2024-04-29 21:17:42
tags:
  - Redis
---

# Redis八股题

:::tip 声明
本文中部分内容摘自网络(下方表示出处)，如有违规可联系我进行删除 🙏🏻
> * [https://github.com/chaseSpace/interview/blob/main/db_redis.md](https://github.com/chaseSpace/interview/blob/main/db_redis.md)
:::

## 1. 说说你对Redis的理解

redis是基于key-value存储结构的NoSQL开源内存数据库，他提供了5种常用的数据结构（string，hash，set，zset，list），针对不同的结构，可以解决不同场景的问题。

其次redis本身是一个基于内存的存储，并且在数据结构上做了大量的一些优化，所以IO的性能笔记哦啊好，在实际开发中，通常把它作为应用和数据库之间的一个分布式缓存中间件，并且redis又是一个非关系型数据库的存储，他不存在表之间的关联查询的问题，所以它可以很好的去提升应用程序的IO数据效率

## 2. Redis为什么那么快

* 纯内存访问，不与磁盘交互
* 单线程避免上下文切换
* 丰富的数据结构
* 多路复用epoll网络模型
* 渐进式ReHash，缓存时间戳等设计
## 3. 为什么Redis使用单线程

* 简单高效：单线程模型使reids开发维护更简单，不需要处理多线程带来的枷锁，线程同步等复杂情况
* 瓶颈不在CPU：redis作为内存数据库，性能瓶颈主要内存和网络带宽
* 数据结构简单：redis的数据结构被专门设计的很简单高效，绝大部分操作的时间复杂度都是O(1)，因此单线程足以应对大部分读写场景
* IO多路复用：利用了操作系统提供的多路IO复用epoll模型，可以高效的监听和处理多个客户端连接。

## 4. Redis使用单线程的瓶颈

* 只能用一个cpu核（忽略后台线程和子线程）
* 如果value比较大，redis的qps会下降的很厉害，有时一个大key就key拖垮
* qps难以更上一层楼

## 5. 为什么Redis后来引入多线程

### Redis4.x

redis 在 4.x 版本引入了多线程，用来异步执行[`UNLINK`](./interview#_6-redis中del和unlink区别) 、`FLUSHALL ASYNC` 、`FLUSHDB ASYNC` 命令。比如对于键的删除，我们一般不需要同步等待完成，而是删除大键是一个耗时操作，所以引入多线程是方便执行那些不需要同步返回的命令。
### Redis6.x中的多线程I/O

Redis官方在2020年5月正式推出6.0版本，此版本正式引入了多线程IO。

首先要解释Redis的单线程：Redis在处理客户端的请求时，包括获取（socket读）、解析、执行、内容返回（socket写）等都由一个顺序串行的主线程执行。

随着硬件性能的提升，Redis的单线程性能瓶颈可能出现网络IO的读写，也就是：单个线程处理网络读写的速度跟不上底层网络硬件的速度，读写网络的`read / write`系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在网络的IO消耗，此时的优化方向：
* 提高网络IO性能，典型的实现比如使用 [`DPDK`](https://zh.wikipedia.org/wiki/DPDK) 来代替内核网络栈的方向
* 使用多线程充分利用多核，提高网络请求读写的并行度，典型的实现比如 `Memcached`

🤔 Redis采用了第二种方式，即Redis采用多个IO线程来处理网络请求，提高网络请求处理的并行度，**需要注意的是**，Redis多IO线程模型只用来处理网络读写请求，对于Redis的读写命令，依然是单线程处理。

**开启多线程 - redis.conf**

Redis的多线程默认是禁用的，只使用主线程，如需开启需要修改redis.conf配置：
```txt
io-threads-do-reads yes
io-threads 4 # 建议为CPU核心数-1
```

## 6. Redis中del和unlink区别
`del`和`unlink`都是用来删除的指令
### del命令

```shell
DEL key [KEY ...]
```
* `del`可以指定多个键名，删除多个键，如果指定的键不存在，则会被忽略
* `del`命令不会释放已经分配的内存，如需释放使用`unlink`
* `del`是一种同步命令，它会阻塞客户端，直到所有指定的键都被删除为止
### unlink命令

```shell
UNLINK key [KEY ...]
```
* `unlink`可以指定多个键名，删除多个键，如果指定的键不存在，则会被忽略
* `unlink`命令会释放已经分配的内存，有大量键需要删除时会减少内存使用量
* `unlink`命令会异步删除指定的键及与之相关联的值，结果立即返回，不会阻塞客户端

## 7. Redis的多路复用和HTTP/2有何不同

### 1. 应用层别不同

HTTP/2 的多路复用发生在应用层，即在一个TCP链接上复用多条流。而Redis的多路复用发生在更底层的网络IO层，即在一个线程中同时处理多个客户端socket连接的IO操作。

### 2. 目的不同

HTTP/2 多路复用的主要目的是减少TCP连接数，提高带宽利用率。Redis的多路复用主要目的是保持单线程以及不必要的上下文切换开销。

## 8. Redis的事务实现

### 事务实现

Redis通过`MULTI`、`DISCARD`、`EXEC`、`WATCH`四个命令来实现事务功能，事务提供了一种“将多个命令打包，然后一次性、按顺序的执行”的机制，并且事务在执行期间不被主动中断，一个事务从开始到执行会经历三个阶段：
* `WATCH`: 在事务开始前，用于监视一个或多个键，如果键的值发生了变化，则EXEC无法执行，事务中断（在`MULTI`前执行）
	* 事务中断后，`WATCH`命令自动取消
	* 单个会话有效
* `UNWATCH`: 取消`WATCH`对所有key的监视（在`MULTI`前执行）
* `MULTI`: 标志着事务开始
* `EXEC`: 服务器以先进先出的顺序执行命令，如果命令执行失败，则继续执行下一条命令，也不会回滚已执行的命令
* `DISCARD`: 取消一个事务（在`EXEC`前执行）
* `输入其他命令`: 命令在服务器入列，命令语法错误会导致`EXEC`无法执行，即事务中断（所有命令都不执行）

🤔 Redis事务(ACID)提供一致性和隔离性，<font color="red"><b>但不提供原子性和持久性</b></font>
* 一致性(Consistency)：指不会出现执行一半命令的情况
* 隔离性(Isolation)：指事务之间互不干扰，同时也不会在事务内插入其他命令
* 原子性(Atomicity)：指事务内的命令全部执行或都不执行，无法做到因为一条命令的运行错误导致其他命令中断
* 持久性(Durability)：因为Redis的持久化都是异步的，做不到实时落盘（为了保证性能）

### 事务使用案例

#### 正常使用

```shell
# 连接到 Redis 服务器
$ redis-cli

# 开启 Redis 事务
127.0.0.1:6379> MULTI

# 执行递增操作
127.0.0.1:6379> INCR counter
QUEUED

# 记录递增值
127.0.0.1:6379> INCR log:counter
QUEUED

# 执行 Redis 事务
127.0.0.1:6379> EXEC
1) (integer) 1
2) (integer) 1

```

#### 验证原子性

```shell
127.0.0.1:6379> SET k1 v1
OK

127.0.0.1:6379> MULTI
OK

127.0.0.1:6379(TX)> SET k2 v2
QUEUED

127.0.0.1:6379(TX)> INCR k1
QUEUED

127.0.0.1:6379(TX)> GET k2
QUEUED

127.0.0.1:6379(TX)> EXEC
1) OK
2) (error) ERR value is not an integer or out of range
3) "v2"
```

#### watch命令

watch命令用于监视一个或多个key，如果在事务执行前这个key被其他命令所改动，那么事务将被打断，可以实现乐观锁。

![img](./1714404711.png)

![img](./1714405171.png)
## 9. Redis会变慢的原因

* 当内存不足是，key可能会频繁被淘汰，响应时间上升
* 频繁的内存持久化，如果数据量大且写操作比较多必然会引起大量的磁盘IO操作，导致性能下降
* 阻塞操作，某些redis命令会导致阻塞，比如阻塞式列表操作，慢查询，当这些操作频繁调用或者执行时间长的时候，会导致整个系统的性能下降，可以使用redis的性能分析工具和命令来识别慢查询和阻塞的操作对并发行进行优化调整
* 网络问题，比如网络延迟和带宽受限

## 10. Redis内存淘汰机制

当 Redis 内存不够用的时候，它根据设置的淘汰策略来删除部分键，支持以下策略：
* `noeviction`: (**默认**)当内存超过配置时就会返回错误，不会驱逐任何键
* `allkeys-lru`: 首先通过LRU算法驱逐最久没有使用的键
* `voliatile-lru`: 首先从设置过期时间的键集合中驱逐最久没有使用的键
* `allkey-random`: 从所有key中随机删除
* `voliatile-random`: 从设置了过期时间的键集合中随机删除
* `voliatile-ttl`: 从配置了过期时间的键中驱逐马上要过期的键
* `voliatile-lfu`: 从所有配置了过期时间的键中驱逐使用频率最少的键
* `voliatile-lfu`: 从所有键中驱逐使用频率最少的键

## 11. Redis存在线程安全问题吗

* `从redis服务端层面`：redis-server本身是一个线程安全的服务，在redis-server端去执行指令的时候不需要任何的同步机制，不会存在任何线程安全的问题。
*  `从redis客户端层面`：虽然redis中的指令操作是原子的，但是如果多个redis客户端同时执行多个指令的情况下，就无法保证原子性。假设两个redis client同时获取redis server的key，同时进行读取和写入，因为多线程下的原子性无法被保障，以及多进程情况下同享资源访问的一个竞争问题，使得数据的安全性无法保障


## 12. 什么是缓存雪崩
## 13. 什么是缓存穿透
## 14. 什么是缓存击穿
