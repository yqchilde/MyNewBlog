import{_ as s}from"./chunks/articleMetadata.Cf_qG6bW.js";import{_ as d,h as c,u as n,B as u,l as t,x as h,ai as _,m,f as l,p,q as b}from"./chunks/framework.h2at8Qew.js";import"./chunks/theme.DtUmdvIn.js";const w=JSON.parse('{"title":"Redis面试题-场景","description":"Redis面经，资源从网络收集","frontmatter":{"sort":2,"title":"Redis面试题-场景","description":"Redis面经，资源从网络收集","date":"2024-04-30T17:19:04.000Z","tags":["Redis"]},"headers":[],"relativePath":"review/redis/interview-2.md","filePath":"posts/review/redis/interview-2/README.md","lastUpdated":1715097095000}'),f={name:"review/redis/interview-2.md"},P=t("h1",{id:"redis面试题-场景",tabindex:"-1"},[h("Redis面试题-场景 "),t("a",{class:"header-anchor",href:"#redis面试题-场景","aria-label":'Permalink to "Redis面试题-场景"'},"​")],-1),R=_('<div class="tip custom-block"><p class="custom-block-title">声明</p><p>本文中部分内容摘自网络(下方表示出处)，如有违规可联系我进行删除 🙏🏻</p><blockquote><ul><li><a href="https://github.com/chaseSpace/interview/blob/main/db_redis.md" target="_blank" rel="noreferrer">https://github.com/chaseSpace/interview/blob/main/db_redis.md</a></li></ul></blockquote></div><details class="details custom-block"><summary>目录索引</summary><nav class="table-of-contents"><ul><li><a href="#_1-缓存">1. 缓存</a></li><li><a href="#_2-延迟队列">2. 延迟队列</a><ul><li><a href="#实现方案">实现方案</a></li><li><a href="#存在问题">存在问题</a></li></ul></li><li><a href="#_3-消息队列">3. 消息队列</a><ul><li><a href="#list实现mq">List实现MQ</a></li></ul></li></ul></nav></details><h2 id="_1-缓存" tabindex="-1">1. 缓存 <a class="header-anchor" href="#_1-缓存" aria-label="Permalink to &quot;1. 缓存&quot;">​</a></h2><p>Redis实现缓存功能的基本原理是将常用的数据存储在内存中，以加快数据访问速度，并且可以通过设置过期时间来自动淘汰过期的缓存数据。适合缓存的数据是那些更新频率较低，访问频率较高的数据，例如商品信息，用户信息等。</p><h2 id="_2-延迟队列" tabindex="-1">2. 延迟队列 <a class="header-anchor" href="#_2-延迟队列" aria-label="Permalink to &quot;2. 延迟队列&quot;">​</a></h2><p>延迟队列是一种用于处理延迟消息的队列，它的主要特点是能够在指定的时间间隔后消费消息（执行任务）。基本上类似一个任务调度服务，只是处理的对象是消息而不是任务，常见使用场景有以下几种：</p><ul><li>在购物平台下单，超时未成功付款，订单进行自动取消</li><li>打车时，规定时间内没有车主接单，订单进行自动取消</li></ul><h3 id="实现方案" tabindex="-1">实现方案 <a class="header-anchor" href="#实现方案" aria-label="Permalink to &quot;实现方案&quot;">​</a></h3><ol><li>在redis中可以使用有序集合（ZSet）来实现延迟消息队列，ZSet有一个Score属性可以用来存储延迟执行的时间。</li><li>使用<code>zadd score1 value1</code>命令就可以一直往内存中生产消息，再利用<code>zrangebyscore</code>查询复合条件的所有待处理的任务，通过循环执行队列任务即可。</li></ol><h3 id="存在问题" tabindex="-1">存在问题 <a class="header-anchor" href="#存在问题" aria-label="Permalink to &quot;存在问题&quot;">​</a></h3><ul><li>消息没有持久化，如果服务器宕机或重启，消息可能会丢失</li><li>没有ACK机制，如果消费失败，消息会丢失。有大佬实现了个支持ACK的 <a href="https://juejin.cn/post/7111939271757398023" target="_blank" rel="noreferrer">🔗 用 Redis 做一个可靠的延迟队列</a></li></ul><h2 id="_3-消息队列" tabindex="-1">3. 消息队列 <a class="header-anchor" href="#_3-消息队列" aria-label="Permalink to &quot;3. 消息队列&quot;">​</a></h2><p>常见消息队列选型Kafka、RocketMQ等服务相对Redis比较重，对于一些简单的，没有大量消息堆积的非关键业务场景可以使用Redis来实现消息队列。</p><p>Redis中可以使用List、Stream、Pub/Sub 来实现简单的消息队列</p><h3 id="list实现mq" tabindex="-1">List实现MQ <a class="header-anchor" href="#list实现mq" aria-label="Permalink to &quot;List实现MQ&quot;">​</a></h3><p>Redis队列是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。通过使用以下命令，可以实现一个简单的消息队列功能：</p><ul><li>LPUSH、RPOP 左进右出</li><li>RPUSH、LPOP 右进左出</li></ul><p>使用RPOP、LPOP命令消费数据时有个问题就是需要消费者轮询Redis，所以可以使用BRPOP、BLPOP避免这个问题。</p><h4 id="实现ack机制" tabindex="-1">实现ACK机制 <a class="header-anchor" href="#实现ack机制" aria-label="Permalink to &quot;实现ACK机制&quot;">​</a></h4><p>Redis中可以使用双队列来实现ACK机制，步骤如下：</p><ul><li>准备两个队列，其中存储数据的队列为<code>queue1</code>，另一个队列名为<code>queue1_bak</code></li><li>消费者使用<code>RPOPLPUSH</code>或<code>BRPOPLPUSH</code>命令消费数据（数据在弹出的同时将备份到另一个 bak 队列）</li><li>消费者消费数据成功后，使用<code>LREM</code>命令消费 bak 队列的数据</li><li>启用定时任务，使用<code>LRANGE</code>命令读取队列数据，解析每条数据（需要包含产生时间戳），将超市消息（认为消费失败）重新入队<code>queue1</code><ul><li>超时定义：因为使用redis的队列场景一般不存在大量消息堆积，所以可以简单定一个时间</li><li>因为这里的超时定义不严谨，所以建议消息中包含唯一ID实现幂等消费，否则可能会重新消费</li></ul></li></ul>',21);function k(e,q,v,S,A,C){const r=s,o=m("ClientOnly");return l(),c("div",null,[P,n(o,null,{default:u(()=>{var a,i;return[(((a=e.$frontmatter)==null?void 0:a.aside)??!0)&&(((i=e.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(l(),p(r,{key:0,article:e.$frontmatter},null,8,["article"])):b("",!0)]}),_:1}),R])}const M=d(f,[["render",k]]);export{w as __pageData,M as default};
